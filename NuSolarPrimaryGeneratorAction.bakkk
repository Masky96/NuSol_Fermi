/*
Dr. Robert McTaggart
South Dakota State University
Fall 2018

This is the routine that fires the initial particles ,
or uses information from particles fired by /gps in a macro
and performs kinematics (if necessary)

 */

#include "G4PhysicalConstants.hh"
#include "G4SystemOfUnits.hh"
#include "G4Event.hh"
#include "G4ParticleTable.hh"
#include "G4ParticleDefinition.hh"
#include "G4GeneralParticleSource.hh"
#include "G4ParticleGun.hh"
#include "Randomize.hh"

#include "G4DecayPhysics.hh"
#include "G4IonTable.hh"
#include "G4ParticlePropertyData.hh"
#include "G4NuclearDecay.hh"

#include "NuSolarPrimaryGeneratorAction.hh"
#include "PrimaryGeneratorMessenger.hh"
#include "globals.hh"

#include "G4RunManager.hh"

#include <vector>


namespace User{

  NuSolarPrimaryGeneratorAction::NuSolarPrimaryGeneratorAction()
  {
   
    G4ParticleTable* particleTable = G4ParticleTable::GetParticleTable();
    G4ParticleDefinition* particle = particleTable->FindParticle("mu-");
    particleGun = new G4GeneralParticleSource();

    //create a messenger for this class
    gunMessenger = new PrimaryGeneratorMessenger(this);

    for(G4int i = 1; i<11; i++){
      std::vector<event*> *thisShower = new std::vector<event*>;
      for(G4int j = 0; j < i; j++){
	event *a;
	a->particleType = particle;
	G4ThreeVector *thisPos = new G4ThreeVector(0,0,1*m);
	a->position = thisPos;
	G4ThreeVector *thisMom = new G4ThreeVector(0,0,-1);
	a->momentum = thisMom;
	G4double *thisEner = new G4double(1*TeV);
	a->energy = thisEner;
	thisShower->vector::push_back(a);
      }
      showers -> vector::push_back(thisShower);
    }
    
    nShowers = showers->vector::size();
    
    //default kinematic

    particleGun->SetParticleDefinition(particle);
    particleGun->SetParticleTime(0.0*ns);

    //create a new Particle Gun that will steal the randomized location of the
    //first particle gun, and use its energy from said gps for the decay products

    G4int n_particle=1;
    fparticleGun = new G4ParticleGun(n_particle);

    energyPri=0;
    





  }

  NuSolarPrimaryGeneratorAction::~NuSolarPrimaryGeneratorAction()
  {
    delete particleGun;
    delete gunMessenger;
    delete fparticleGun;
  }


  void NuSolarPrimaryGeneratorAction::GeneratePrimaries(G4Event* anEvent)
  {

    //The variable neutrinoprocess controls whether we are studying the background (neutrinoprocess=0)
    //    or
    // neutrino + 69Ga --> m69Ge + e- ; 
    //                     m69Ge --> 69Ge + gamma

    //   or
    // neutrino + 71Ga --> m71Ge + e- ;
    //                     m71Ge --> 71Ge + gamma

    //Note that the germanium state CAN be the ground state (no gamma)

    //For neutrino studies we select the detector as a volume source and choose the neutrino
    //energy in phys.mac.  That will randomize the location of the neutrino event.
    //The initial neutrino momentum will be in the +z direction from the sun.

    //Neutrino runs steal this energy and the location generated by general particle source, 
    //and then fire the particle gun for the by-products of the neutrino event. 
      
    //For pure background analyses, we use the general particle source governed by the macros batch.mac and phys.mac. 

    G4cout.precision(16); 
    
    // Initialize I think
    energyPri = 0.;
    particleGun->GeneratePrimaryVertex(anEvent);

    // get the energy from the first particle gun
    energyPri = particleGun->GetParticleEnergy();
    position=particleGun->GetParticlePosition();
    direction=particleGun->GetParticleMomentumDirection();

    G4ThreeVector GunPosition = particleGun->GetParticlePosition();
      
    G4ParticleTable* particleTable = G4ParticleTable::GetParticleTable();
    G4IonTable* ionTable = G4IonTable::GetIonTable();












    

 float ShowerArray[100][10];
    std::ifstream file("shower.out");

    for(int row = 0; row < 100; ++row)
    {
        std::string line;
        std::getline(file, line);
        if ( !file.good() )
            break;
	line.append(",");
        std::stringstream iss(line);

        for (int col = 0; col <= 10; ++col)
        {
            std::string val;
            std::getline(iss, val, ',');
            if ( !iss.good() )
                break;

            std::stringstream convertor(val);
            convertor >> ShowerArray[row][col];
        }
    }

    













      G4ParticleDefinition* neutron = particleTable->FindParticle("neutron");
      G4ParticleDefinition* proton = particleTable->FindParticle("proton");
      G4ParticleDefinition* pion = particleTable->FindParticle("pi-");
      G4ParticleDefinition* muon = particleTable->FindParticle("mu-");
      G4ParticleDefinition* electron = particleTable->FindParticle("e-");
      G4ParticleDefinition* photon = particleTable->FindParticle("gamma");

      //event* thisEvent = new event;



	for(int j = 1; j <= 99; ++j){
	if(ShowerArray[j][2] == 0){	fparticleGun->SetParticleDefinition(neutron);}
	if(ShowerArray[j][2] == 1){	fparticleGun->SetParticleDefinition(proton);}
	if(ShowerArray[j][2] == 2){	fparticleGun->SetParticleDefinition(pion);}
	if(ShowerArray[j][2] == 4){	fparticleGun->SetParticleDefinition(muon);}
	if(ShowerArray[j][2] == 5){	fparticleGun->SetParticleDefinition(electron);}
	if(ShowerArray[j][2] == 6){	fparticleGun->SetParticleDefinition(photon);}
	fparticleGun->SetParticleMomentumDirection(G4ThreeVector(ShowerArray[j][7],ShowerArray[j][8],ShowerArray[j][9]));
	fparticleGun->SetParticleEnergy(ShowerArray[j][3]*keV);
	fparticleGun->SetParticlePosition(G4ThreeVector(ShowerArray[j][4]*cm,ShowerArray[j][5]*cm,24*cm));
	fparticleGun->SetParticleTime(0.0*ns);
	fparticleGun->GeneratePrimaryVertex(anEvent); 
	}














	/*
    G4ParticleDefinition* electron = particleTable -> FindParticle("e-");
    G4ParticleDefinition* muon = particleTable -> FindParticle("mu-");
    for(G4int i =0; i<11; i++){
      G4cout << i << "th event begins\n";
      fparticleGun->SetParticleDefinition(electron);
      fparticleGun->SetParticleMomentumDirection(G4ThreeVector(-1,0,0));
      fparticleGun->SetParticleEnergy(0.01);
      fparticleGun->SetParticlePosition(G4ThreeVector(1000,0,(i*20-100)));
      fparticleGun->SetParticleTime(0.0*ns);
      fparticleGun->GeneratePrimaryVertex(anEvent); 
    }
	*/

    
  }
  
  void NuSolarPrimaryGeneratorAction::SetOptPhotonPolar(G4double angle)
  {
    if (particleGun->GetParticleDefinition()->GetParticleName() != "opticalphoton")
      {
	G4cout << "--> warning from NuSolarPrimaryGeneratorAction::SetOptPhotonPolar() :"
	  "the particleGun is not an opticalphoton" << G4endl;
	return;
      }
           
    G4ThreeVector normal (1., 0., 0.);
    G4ThreeVector kphoton = particleGun->GetParticleMomentumDirection();
    G4ThreeVector product = normal.cross(kphoton); 
    G4double modul2       = product*product;
 
    G4ThreeVector e_perpend (0., 0., 1.);
    if (modul2 > 0.) {
      e_perpend = (1./sqrt(modul2))*product;
    } 
    G4ThreeVector e_paralle    = e_perpend.cross(kphoton);
    
    G4ThreeVector polar = cos(angle)*e_paralle + sin(angle)*e_perpend;
    particleGun->SetParticlePolarization(polar);
  }
 

  } //end User namespace
